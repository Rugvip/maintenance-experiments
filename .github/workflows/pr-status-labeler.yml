name: PR Status Labeler

on:
  pull_request:
    types: [opened, synchronize, reopened, labeled, unlabeled]
  pull_request_review:
    types: [submitted, dismissed]
  issue_comment:
    types: [created, edited]

jobs:
  label:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
      issues: write
    steps:
      - name: Update status label based on PR state
        uses: actions/github-script@v8
        with:
          script: |
            const PROJECT_OWNER = 'Rugvip';
            const PROJECT_NUMBER = 4;

            const labelStatusMap = new Map([
              ['status:needs-changes', 'Needs Changes'],
              ['status:needs-review', 'Needs Review'],
              ['status:needs-owner-review', 'Needs Owner Review'],
              ['status:needs-decision', 'Needs Decision'],
              ['status:awaiting-merge', 'Awaiting Merge'],
            ]);

            const statusLabels = new Set(labelStatusMap.keys());

            function getPrNumber() {
              if (context.payload.pull_request) {
                return context.payload.pull_request.number;
              }
              if (context.payload.issue?.pull_request) {
                return context.payload.issue.number;
              }
              return null;
            }

            async function removeLabels(labels) {
              for (const label of labels) {
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  name: label,
                });
              }
            }

            async function addLabel(label) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                labels: [label],
              });
            }

            async function syncLabelToProject(labelName) {
              if (!labelName) return;

              const statusName = labelStatusMap.get(labelName);
              if (!statusName) return;

              try {
                const fieldsResponse = await github.request('GET /users/{username}/projectsV2/{project_number}/fields', {
                  username: PROJECT_OWNER,
                  project_number: PROJECT_NUMBER,
                });

                const statusField = fieldsResponse.data.find(
                  f => f.name === 'Status' && f.data_type === 'single_select'
                );
                if (!statusField) return;

                const statusOption = (statusField.options || []).find(opt => opt.name === statusName);
                if (!statusOption) return;

                const itemsResponse = await github.request('GET /users/{username}/projectsV2/{project_number}/items', {
                  username: PROJECT_OWNER,
                  project_number: PROJECT_NUMBER,
                });

                const item = itemsResponse.data.find(i => {
                  const url = i.content?.url || '';
                  return url.includes(`/pulls/${prNumber}`) || url.includes(`/issues/${prNumber}`);
                });

                if (!item) return;

                await github.request('PATCH /users/{username}/projectsV2/{project_number}/items/{item_id}', {
                  username: PROJECT_OWNER,
                  project_number: PROJECT_NUMBER,
                  item_id: item.id,
                  body: {
                    fields: {
                      [statusField.id]: {
                        single_select_option_id: statusOption.id,
                      },
                    },
                  },
                });
              } catch (error) {
                console.log(`Error syncing to project:`, error.message);
              }
            }

            async function determineTargetLabel() {
              if (context.eventName === 'pull_request' && context.payload.action === 'labeled') {
                const addedLabel = context.payload.label?.name;
                if (statusLabels.has(addedLabel)) {
                  return addedLabel;
                }
              }

              if (context.eventName === 'pull_request' && context.payload.action === 'unlabeled') {
                const removedLabel = context.payload.label?.name;
                if (statusLabels.has(removedLabel)) {
                  return 'status:needs-review';
                }
              }

              const { data: pr } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
              });

              const existingLabels = new Set(pr.labels.map(l => l.name));
              const hasNeedsDecision = existingLabels.has('status:needs-decision');
              const hasNeedsChanges = existingLabels.has('status:needs-changes');
              const prAuthor = pr.user.login;

              if (hasNeedsDecision && !(context.eventName === 'pull_request' && context.payload.action === 'labeled')) {
                return null;
              }

              if (hasNeedsChanges) {
                const isAuthorAction =
                  (context.eventName === 'issue_comment' && context.payload.comment.user.login === prAuthor) ||
                  (context.eventName === 'pull_request' && context.payload.action === 'synchronize' && context.payload.sender?.login === prAuthor);

                if (isAuthorAction) {
                  return 'status:needs-review';
                }
              }

              async function getReviews() {
                const { data: reviews } = await github.rest.pulls.listReviews({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber,
                });
                return reviews;
              }

              if (context.eventName === 'pull_request_review') {
                const action = context.payload.action;
                if (action === 'dismissed') {
                  const reviews = await getReviews();
                  const hasChangesRequested = reviews.some(r => r.state === 'CHANGES_REQUESTED');
                  const hasApprovals = reviews.some(r => r.state === 'APPROVED');
                  if (hasChangesRequested) return 'status:needs-changes';
                  if (hasApprovals) return 'status:awaiting-merge';
                  return 'status:needs-review';
                }

                const review = context.payload.review;
                if (review.state === 'changes_requested') {
                  return 'status:needs-changes';
                }
                if (review.state === 'approved') {
                  const reviews = await getReviews();
                  const hasChangesRequested = reviews.some(r => r.state === 'CHANGES_REQUESTED');
                  return hasChangesRequested ? 'status:needs-changes' : 'status:awaiting-merge';
                }
              }

              if (context.eventName === 'pull_request') {
                const action = context.payload.action;
                if (action === 'opened' || action === 'synchronize' || action === 'reopened') {
                  const reviews = await getReviews();
                  const hasChangesRequested = reviews.some(r => r.state === 'CHANGES_REQUESTED');
                  const hasApprovals = reviews.some(r => r.state === 'APPROVED');
                  if (hasChangesRequested) return 'status:needs-changes';
                  if (hasApprovals) return 'status:awaiting-merge';
                  return 'status:needs-review';
                }
              }

              if (context.eventName === 'issue_comment') {
                const comment = context.payload.comment;
                if (comment.user.type !== 'Bot') {
                  const reviews = await getReviews();
                  const hasChangesRequested = reviews.some(r => r.state === 'CHANGES_REQUESTED');
                  if (hasChangesRequested) return 'status:needs-changes';
                }
              }

              return null;
            }

            const prNumber = getPrNumber();
            if (!prNumber) return;

            const targetLabel = await determineTargetLabel();

            if (targetLabel === null) {
              const { data: pr } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
              });
              const existingLabels = new Set(pr.labels.map(l => l.name));
              const existingStatusLabels = existingLabels.intersection(statusLabels);
              if (existingStatusLabels.size === 0) {
                const defaultLabel = 'status:needs-review';
                await removeLabels(existingStatusLabels);
                await addLabel(defaultLabel);
                await syncLabelToProject(defaultLabel);
              }
              return;
            }

            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
            });

            const existingLabels = new Set(pr.labels.map(l => l.name));
            const existingStatusLabels = existingLabels.intersection(statusLabels);
            const labelsToRemove = existingStatusLabels.difference(new Set([targetLabel]));

            await removeLabels(labelsToRemove);

            if (!existingLabels.has(targetLabel)) {
              await addLabel(targetLabel);
              await syncLabelToProject(targetLabel);
            } else {
              await syncLabelToProject(targetLabel);
            }
