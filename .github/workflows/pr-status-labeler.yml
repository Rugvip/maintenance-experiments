name: PR Status Labeler

on:
  pull_request:
    types: [opened, synchronize, reopened]
  pull_request_review:
    types: [submitted, dismissed]
  issue_comment:
    types: [created, edited]
  label:
    types: [created]

jobs:
  label:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
      issues: write
    steps:
      - name: Update status label based on PR state
        uses: actions/github-script@v8
        with:
          script: |
            // Get PR number - handle different event types
            let prNumber = null;
            if (context.payload.pull_request) {
              prNumber = context.payload.pull_request.number;
            } else if (context.payload.issue) {
              // For label events and issue_comment events, check if it's a PR
              if (context.payload.issue.pull_request) {
                prNumber = context.payload.issue.number;
              } else {
                // It's an issue, not a PR, skip
                return;
              }
            } else {
              return;
            }

            // Define mutually exclusive status labels
            const statusLabels = new Set([
              'status:needs-changes',
              'status:needs-review',
              'status:needs-owner-review',
              'status:needs-decision',
              'status:awaiting-merge',
            ]);

            // Helper function for Set intersection
            const intersection = (set1, set2) => new Set([...set1].filter(x => set2.has(x)));
            // Helper function for Set difference
            const difference = (set1, set2) => new Set([...set1].filter(x => !set2.has(x)));

            // Get current PR and labels first to check for needs-decision
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
            });

            const existingLabels = new Set(pr.labels.map(label => label.name));
            const hasNeedsDecision = existingLabels.has('status:needs-decision');
            const hasNeedsChanges = existingLabels.has('status:needs-changes');
            const prAuthor = pr.user.login;

            // If status is needs-changes and PR author comments or pushes, change to needs-review
            if (hasNeedsChanges) {
              let isAuthorAction = false;

              if (context.eventName === 'issue_comment') {
                const comment = context.payload.comment;
                if (comment.user.login === prAuthor) {
                  isAuthorAction = true;
                }
              } else if (context.eventName === 'pull_request' && context.payload.action === 'synchronize') {
                // Check if the pusher is the PR author
                const sender = context.payload.sender?.login;
                if (sender === prAuthor) {
                  isAuthorAction = true;
                }
              }

              if (isAuthorAction) {
                const existingStatusLabels = intersection(existingLabels, statusLabels);
                const needsReviewLabel = 'status:needs-review';
                const needsReviewSet = new Set([needsReviewLabel]);
                const alreadyHasNeedsReview = existingLabels.has(needsReviewLabel);

                // Remove existing status labels except needs-review
                const labelsToRemove = difference(existingStatusLabels, needsReviewSet);

                for (const label of labelsToRemove) {
                  await github.rest.issues.removeLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: prNumber,
                    name: label,
                  });
                }

                // Add needs-review label only if not already present
                if (!alreadyHasNeedsReview) {
                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: prNumber,
                    labels: [needsReviewLabel],
                  });
                }
                console.log(`Changed status from needs-changes to needs-review after PR author action`);
                return;
              }
            }

            // Handle manual label addition
            if (context.eventName === 'label') {
              const addedLabel = context.payload.label?.name;
              if (statusLabels.has(addedLabel)) {
                // Remove all other status labels except the one just added
                const existingStatusLabels = intersection(existingLabels, statusLabels);
                const addedLabelSet = new Set([addedLabel]);
                const labelsToRemove = difference(existingStatusLabels, addedLabelSet);

                for (const label of labelsToRemove) {
                  await github.rest.issues.removeLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: prNumber,
                    name: label,
                  });
                }
                console.log(`Cleaned up other status labels after manual addition of ${addedLabel}`);
                return;
              }
            }

            // If needs-decision is set, don't automatically update (unless manually removed)
            if (hasNeedsDecision && context.eventName !== 'label') {
              console.log('status:needs-decision is set, skipping automatic label update');
              return;
            }

            // Determine which label to apply based on the event
            let newLabel = null;

            // Handle PR review events
            if (context.eventName === 'pull_request_review') {
              const action = context.payload.action;

              // If review is dismissed, re-evaluate based on remaining reviews
              if (action === 'dismissed') {
                const { data: reviews } = await github.rest.pulls.listReviews({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber,
                });

                const hasChangesRequested = reviews.some(r => r.state === 'CHANGES_REQUESTED');
                const hasApprovals = reviews.some(r => r.state === 'APPROVED');

                if (hasChangesRequested) {
                  newLabel = 'status:needs-changes';
                } else if (hasApprovals) {
                  newLabel = 'status:awaiting-merge';
                } else {
                  newLabel = 'status:needs-review';
                }
              } else {
                const review = context.payload.review;
                if (review.state === 'changes_requested') {
                  newLabel = 'status:needs-changes';
                } else if (review.state === 'approved') {
                  // Check if there are other pending reviews or if it's ready
                  const { data: reviews } = await github.rest.pulls.listReviews({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: prNumber,
                  });

                  // Check if there are any "changes_requested" reviews
                  const hasChangesRequested = reviews.some(r => r.state === 'CHANGES_REQUESTED');
                  if (!hasChangesRequested) {
                    newLabel = 'status:awaiting-merge';
                  } else {
                    newLabel = 'status:needs-changes';
                  }
                } else if (review.state === 'commented' && !hasNeedsDecision) {
                  newLabel = 'status:needs-decision';
                }
              }
            }

            // Handle PR opened/updated events
            else if (context.eventName === 'pull_request') {
              const action = context.payload.action;
              if (action === 'opened' || action === 'synchronize' || action === 'reopened') {
                // Check existing reviews to determine state
                const { data: reviews } = await github.rest.pulls.listReviews({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber,
                });

                const hasChangesRequested = reviews.some(r => r.state === 'CHANGES_REQUESTED');
                const hasApprovals = reviews.some(r => r.state === 'APPROVED');

                if (hasChangesRequested) {
                  newLabel = 'status:needs-changes';
                } else if (hasApprovals && !hasChangesRequested) {
                  newLabel = 'status:awaiting-merge';
                } else {
                  newLabel = 'status:needs-review';
                }
              }
            }

            // Handle comments (could indicate discussion needed)
            else if (context.eventName === 'issue_comment') {
              const comment = context.payload.comment;
              // Only process if comment is not from a bot and is on a PR
              if (!comment.user.type || comment.user.type !== 'Bot') {
                // Check if PR has changes requested - if so, comment might be about fixes
                const { data: reviews } = await github.rest.pulls.listReviews({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber,
                });

                const hasChangesRequested = reviews.some(r => r.state === 'CHANGES_REQUESTED');
                if (hasChangesRequested) {
                  newLabel = 'status:needs-changes';
                } else if (!hasNeedsDecision) {
                  newLabel = 'status:needs-decision';
                }
              }
            }

            // If no label determined, skip
            if (!newLabel) {
              console.log('No status label determined for this event');
              return;
            }

            const existingStatusLabels = intersection(existingLabels, statusLabels);
            const alreadyHasNewLabel = existingLabels.has(newLabel);

            // Remove existing status labels except the one we're about to add
            const newLabelSet = new Set([newLabel]);
            const labelsToRemove = difference(existingStatusLabels, newLabelSet);

            for (const label of labelsToRemove) {
              await github.rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                name: label,
              });
            }

            // Add the new status label only if it's not already present
            if (!alreadyHasNewLabel) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                labels: [newLabel],
              });
              console.log(`Applied label: ${newLabel}`);
            } else {
              console.log(`Label ${newLabel} already present, skipped adding`);
            }
